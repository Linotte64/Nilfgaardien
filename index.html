!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traducteur de Langue Construite</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh; padding: 20px;
        }
        .container {
            max-width: 1000px; margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px; box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        .header { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; text-align: center; padding: 30px; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .translator-section { padding: 40px; }
        .language-selector { display: flex; justify-content: center; align-items: center; margin-bottom: 30px; gap: 20px; }
        .lang-option { background: #f8f9fa; border: 2px solid #e9ecef; border-radius: 15px; padding: 15px 25px; cursor: pointer; font-weight: 600; }
        .lang-option.active { background: linear-gradient(135deg, #667eea, #764ba2); color: white; }
        .swap-btn { background: linear-gradient(135deg, #ff6b6b, #feca57); border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; color: white; font-size: 20px; }
        .translation-area { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px; }
        textarea { width: 100%; height: 150px; border: 2px solid #e9ecef; border-radius: 15px; padding: 20px; font-size: 16px; resize: none; }
        .analysis { background: #f8f9fa; border-radius: 15px; padding: 20px; margin-top: 20px; display: none; }
        .word-tag { background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 5px 10px; margin: 5px; display: inline-block; font-size: 14px; }
        .dictionary { background: #fff; border-radius: 15px; padding: 20px; margin-top: 30px; border: 1px solid #e9ecef; }
        .dict-entry { padding: 8px 0; border-bottom: 1px solid #f1f3f4; }
        .vocab-note { background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 10px; padding: 15px; margin-bottom: 20px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚ú® Traducteur de Langue Construite ‚ú®</h1>
            <p>Focus Grammaire & Conjugaisons</p>
        </div>
        <div class="translator-section">
            <div class="vocab-note">
                <strong>üìù Version simplifi√©e</strong> - Vocabulaire minimal pour tester la grammaire et les conjugaisons. Le vocabulaire complet sera ajout√© plus tard !
            </div>
            
            <div class="language-selector">
                <div class="lang-option active">Votre Langue</div>
                <button class="swap-btn" onclick="swapLanguages()">‚áÑ</button>
                <div class="lang-option">Fran√ßais</div>
            </div>
            <div class="translation-area">
                <div>
                    <h3 id="input-label">Votre Langue</h3>
                    <textarea id="input-text" placeholder="Testez : deithwen, grurnir, mares...">deithwen grurnir osk mares nork</textarea>
                </div>
                <div>
                    <h3 id="output-label">Fran√ßais</h3>
                    <textarea id="output-text" placeholder="La traduction appara√Ætra ici..." readonly></textarea>
                </div>
            </div>
            <div class="analysis" id="analysis">
                <h4>üìã Analyse Grammaticale</h4>
                <div id="word-analysis"></div>
                <div id="grammar-notes"></div>
            </div>
            <div class="dictionary" style="display: none;">
                <h3>üìö Vocabulaire Test</h3>
                <div id="dictionary-content"></div>
            </div>
        </div>
    </div>

    <script>
        // === VOCABULAIRE MINIMAL POUR TESTER ===
        
        // Expressions compos√©es (PRIORIT√â ABSOLUE)
        const basicLexicon = {
            'deithwen': { fr: 'flamme blanche', type: 'nom compos√©' },
            'va faill': { fr: 'au revoir', type: 'formule' },
            'drae\'skorr': { fr: 'sauvage', type: 'adjectif' },
            
            // Mots de base
            'skel': { fr: 'la', type: 'article' },
            'osk': { fr: 'mais', type: 'conjonction' },
            'nork': { fr: 'ne...pas', type: 'n√©gation' },
            'y': { fr: 'et', type: 'conjonction' },
            'thu': { fr: 'tu', type: 'pronom' },
            'wen': { fr: 'blanc', type: 'adjectif' },
            'deith': { fr: 'flamme', type: 'nom' }
        };

        // Quelques noms pour test
        const nouns = {
            'gorval': { fr: 'b√™te', gender_fr: 'f', gender_conlang: 'm' },
            'mithel': { fr: 'chat', gender_fr: 'm', gender_conlang: 'f' }
        };

        // Verbes essentiels pour tester conjugaisons
        const verbs = {
            'grurnir': { radical: 'grurn', fr: 'grogner' },
            'kravnyar': { radical: 'kravny', fr: 'mordre' },
            'mare': { radical: 'mar', fr: 'voir' },
            'ess': { radical: 'ess', fr: '√™tre' },
            'var': { radical: 'var', fr: 'aller' },
            'gleith': { radical: 'glei', fr: 'savoir' }
        };

        let currentDirection = 'conlang-to-french';

        // === SYST√àME DE CONJUGAISON COMPLET ===
        
        // Terminaisons nilfgaardiennes
        const nilf_endings = {
            pr√©sent: { 
                'je': 'en', 'tu': 'es', 'il': '', 'elle': '', 
                'nous': 'avam', 'vous': 'avel', 'ils': 'arin', 'elles': 'arin' 
            },
            futur: { 
                'je': 'rash', 'tu': 'resh', 'il': 'rin', 'elle': 'rin', 
                'nous': 'ravam', 'vous': 'ravel', 'ils': 'ranim', 'elles': 'ranim' 
            },
            imparfait: { 
                'je': 'ien', 'tu': 'ias', 'il': 'ier', 'elle': 'ier', 
                'nous': 'iavem', 'vous': 'iavel', 'ils': 'iarn', 'elles': 'iarn' 
            }
        };

        // === FONCTIONS DE PR√âSERVATION DE CASSE ===
        function preserveCase(original, target) {
            if (!original || !target) return target;
            if (original === original.toUpperCase()) return target.toUpperCase();
            if (original[0] === original[0].toUpperCase()) return target.charAt(0).toUpperCase() + target.slice(1);
            return target;
        }

        // === D√âTECTION DES EXPRESSIONS COMPOS√âES ===
        function findCompoundExpressions(text) {
            const expressions = [];
            const textLower = text.toLowerCase();
            
            // Trier par longueur d√©croissante (expressions les plus longues d'abord)
            const sortedKeys = Object.keys(basicLexicon)
                .filter(key => key.includes(' ') || key.includes('\''))
                .sort((a, b) => b.length - a.length);
            
            for (const key of sortedKeys) {
                const index = textLower.indexOf(key.toLowerCase());
                if (index !== -1) {
                    // V√©rifier que c'est un mot complet (pas partie d'un autre mot)
                    const before = index === 0 || /\s/.test(textLower[index - 1]);
                    const after = index + key.length === textLower.length || /\s/.test(textLower[index + key.length]);
                    
                    if (before && after) {
                        const originalText = text.substring(index, index + key.length);
                        expressions.push({
                            start: index,
                            end: index + key.length,
                            original: originalText,
                            key: key,
                            translation: basicLexicon[key].fr,
                            type: basicLexicon[key].type
                        });
                    }
                }
            }
            
            // √âviter les chevauchements
            expressions.sort((a, b) => a.start - b.start);
            const filteredExpressions = [];
            let lastEnd = 0;
            for (const expr of expressions) {
                if (expr.start >= lastEnd) {
                    filteredExpressions.push(expr);
                    lastEnd = expr.end;
                }
            }
            
            return filteredExpressions;
        }

        // === CONJUGAISONS FRAN√áAISES COMPL√àTES ===
        function conjugateFrench(infinitif, person, tense = 'pr√©sent') {
            // Verbes irr√©guliers sp√©ciaux
            if (infinitif === 'grogner') {
                if (tense === 'pr√©sent') {
                    const forms = { je: 'grogne', tu: 'grognes', il: 'grogne', elle: 'grogne', nous: 'grognons', vous: 'grognez', ils: 'grognent', elles: 'grognent' };
                    return forms[person] || infinitif;
                }
            }
            
            if (infinitif === 'mordre') {
                if (tense === 'pr√©sent') {
                    const forms = { je: 'mords', tu: 'mords', il: 'mord', elle: 'mord', nous: 'mordons', vous: 'mordez', ils: 'mordent', elles: 'mordent' };
                    return forms[person] || infinitif;
                }
            }
            
            if (infinitif === 'voir') {
                if (tense === 'pr√©sent') {
                    const forms = { je: 'vois', tu: 'vois', il: 'voit', elle: 'voit', nous: 'voyons', vous: 'voyez', ils: 'voient', elles: 'voient' };
                    return forms[person] || infinitif;
                }
            }
            
            if (infinitif === '√™tre') {
                if (tense === 'pr√©sent') {
                    const forms = { je: 'suis', tu: 'es', il: 'est', elle: 'est', nous: 'sommes', vous: '√™tes', ils: 'sont', elles: 'sont' };
                    return forms[person] || infinitif;
                }
            }
            
            if (infinitif === 'aller') {
                if (tense === 'pr√©sent') {
                    const forms = { je: 'vais', tu: 'vas', il: 'va', elle: 'va', nous: 'allons', vous: 'allez', ils: 'vont', elles: 'vont' };
                    return forms[person] || infinitif;
                }
            }
            
            if (infinitif === 'savoir') {
                if (tense === 'pr√©sent') {
                    const forms = { je: 'sais', tu: 'sais', il: 'sait', elle: 'sait', nous: 'savons', vous: 'savez', ils: 'savent', elles: 'savent' };
                    return forms[person] || infinitif;
                }
            }
            
            // Conjugaisons automatiques pour verbes en -er
            if (infinitif.endsWith('er') && tense === 'pr√©sent') {
                const radical = infinitif.slice(0, -2);
                const endings = { je: 'e', tu: 'es', il: 'e', elle: 'e', nous: 'ons', vous: 'ez', ils: 'ent', elles: 'ent' };
                return radical + (endings[person] || '');
            }
            
            return infinitif;
        }

        // === CONJUGAISONS NILFGAARDIENNES ===
        function conjugateNilfgaardian(infinitif, person, tense = 'pr√©sent') {
            const verb = verbs[infinitif.toLowerCase()];
            if (!verb) return infinitif;
            
            // 3e personne singulier = forme infinitive en nilfgaardien
            if ((person === 'il' || person === 'elle') && tense === 'pr√©sent') {
                return infinitif;
            }
            
            const ending = nilf_endings[tense] ? nilf_endings[tense][person] : '';
            return verb.radical + ending;
        }

        // === D√âTECTION DES VERBES CONJUGU√âS FRAN√áAIS ===
        function findFrenchVerb(conjugatedForm) {
            for (const [infinitif, verbData] of Object.entries(verbs)) {
                for (const tense of ['pr√©sent', 'futur', 'imparfait']) {
                    for (const person of ['je', 'tu', 'il', 'elle', 'nous', 'vous', 'ils', 'elles']) {
                        const frenchForm = conjugateFrench(verbData.fr, person, tense);
                        if (frenchForm.toLowerCase() === conjugatedForm.toLowerCase()) {
                            return { infinitif: verbData.fr, person: person, nilfInfinitif: infinitif, tense: tense };
                        }
                    }
                }
            }
            return null;
        }

        // === D√âTECTION DU SUJET ===
        function detectSubject(words, direction) {
            if (direction === 'french-to-conlang') {
                // Chercher pronoms fran√ßais
                const pronouns = ['je', 'tu', 'il', 'elle', 'nous', 'vous', 'ils', 'elles'];
                for (const word of words) {
                    if (pronouns.includes(word.toLowerCase())) {
                        return { person: word.toLowerCase(), source: 'pronoun' };
                    }
                }
                
                // Chercher par forme verbale
                for (const word of words) {
                    const verbInfo = findFrenchVerb(word);
                    if (verbInfo) {
                        return { person: verbInfo.person, source: 'verb', verb: word };
                    }
                }
            } else {
                // Pour nilfgaardien, d√©tecter par noms
                for (const word of words) {
                    const noun = nouns[word.toLowerCase()];
                    if (noun) {
                        return { person: noun.gender_fr === 'm' ? 'il' : 'elle', source: 'noun', noun: word };
                    }
                }
            }
            
            return { person: 'il', source: 'default' };
        }

        // === TRADUCTION NILFGAARDIEN ‚Üí FRAN√áAIS ===
        function translateToFrench(text) {
            // 1. Traiter expressions compos√©es d'abord
            const compounds = findCompoundExpressions(text);
            let processedText = text;
            let offset = 0;
            let translation = [];
            let analysis = [];
            let grammarNotes = [];
            
            // Remplacer expressions par marqueurs temporaires
            const markers = [];
            compounds.forEach((compound, index) => {
                const marker = `__COMPOUND_${index}__`;
                markers.push({
                    marker: marker,
                    original: compound.original,
                    translation: preserveCase(compound.original, compound.translation),
                    type: compound.type
                });
                
                const start = compound.start - offset;
                const end = compound.end - offset;
                processedText = processedText.substring(0, start) + marker + processedText.substring(end);
                offset += (compound.end - compound.start) - marker.length;
            });
            
            // 2. Traiter mots individuels
            const words = processedText.split(/\s+/);
            const { person: subject } = detectSubject(words, 'conlang-to-french');
            
            // G√©rer n√©gation avec "nork"
            let processedWords = [];
            let i = 0;
            while (i < words.length) {
                if (i < words.length - 1 && words[i + 1].toLowerCase() === 'nork') {
                    processedWords.push({ word: words[i], negated: true });
                    i += 2;
                } else {
                    processedWords.push({ word: words[i], negated: false });
                    i++;
                }
            }
            
            processedWords.forEach(({ word, negated }) => {
                // V√©rifier marqueurs d'expressions compos√©es
                const markerMatch = markers.find(m => m.marker === word);
                if (markerMatch) {
                    translation.push(markerMatch.translation);
                    analysis.push({ 
                        original: markerMatch.original, 
                        translation: markerMatch.translation, 
                        type: markerMatch.type + ' (compos√©)' 
                    });
                    return;
                }
                
                // Lexique de base
                const basicEntry = Object.keys(basicLexicon).find(key => key.toLowerCase() === word.toLowerCase());
                if (basicEntry) {
                    const translatedWord = preserveCase(word, basicLexicon[basicEntry].fr);
                    translation.push(translatedWord);
                    analysis.push({ original: word, translation: translatedWord, type: basicLexicon[basicEntry].type });
                    return;
                }
                
                // Noms
                const nounEntry = Object.keys(nouns).find(key => key.toLowerCase() === word.toLowerCase());
                if (nounEntry) {
                    const translatedWord = preserveCase(word, nouns[nounEntry].fr);
                    translation.push(translatedWord);
                    analysis.push({ original: word, translation: translatedWord, type: 'nom' });
                    return;
                }
                
                // Verbes (avec conjugaison)
                const verbEntry = Object.keys(verbs).find(key => key.toLowerCase() === word.toLowerCase());
                if (verbEntry) {
                    let frenchForm = conjugateFrench(verbs[verbEntry].fr, subject, 'pr√©sent');
                    if (negated) {
                        frenchForm = 'ne ' + frenchForm + ' pas';
                        grammarNotes.push(`N√©gation appliqu√©e √† "${word}"`);
                    }
                    const finalForm = preserveCase(word, frenchForm);
                    translation.push(finalForm);
                    analysis.push({ 
                        original: word + (negated ? ' nork' : ''), 
                        translation: finalForm, 
                        type: 'verbe (' + subject + ', pr√©sent)' 
                    });
                    return;
                }
                
                // Mot inconnu
                translation.push(`[${word}]`);
                analysis.push({ original: word, translation: `[inconnu]`, type: 'inconnu' });
            });
            
            return { translation: translation.join(' '), analysis, grammar: grammarNotes };
        }

        // === TRADUCTION FRAN√áAIS ‚Üí NILFGAARDIEN ===
        function translateToConlang(text) {
            // 1. Expressions compos√©es fran√ßaises
            const compounds = [];
            const textLower = text.toLowerCase();
            
            for (const [key, value] of Object.entries(basicLexicon)) {
                if (value.fr.includes(' ') && textLower.includes(value.fr.toLowerCase())) {
                    const index = textLower.indexOf(value.fr.toLowerCase());
                    if (index !== -1) {
                        const before = index === 0 || /\s/.test(textLower[index - 1]);
                        const after = index + value.fr.length === textLower.length || /\s/.test(textLower[index + value.fr.length]);
                        
                        if (before && after) {
                            const originalText = text.substring(index, index + value.fr.length);
                            compounds.push({
                                start: index,
                                end: index + value.fr.length,
                                original: originalText,
                                key: key,
                                translation: key,
                                type: value.type
                            });
                        }
                    }
                }
            }
            
            // Traitement similaire avec marqueurs...
            compounds.sort((a, b) => a.start - b.start);
            const filteredCompounds = [];
            let lastEnd = 0;
            for (const expr of compounds) {
                if (expr.start >= lastEnd) {
                    filteredCompounds.push(expr);
                    lastEnd = expr.end;
                }
            }
            
            let processedText = text;
            let offset = 0;
            const markers = [];
            filteredCompounds.forEach((compound, index) => {
                const marker = `__COMPOUND_${index}__`;
                markers.push({
                    marker: marker,
                    original: compound.original,
                    translation: preserveCase(compound.original, compound.translation),
                    type: compound.type
                });
                
                const start = compound.start - offset;
                const end = compound.end - offset;
                processedText = processedText.substring(0, start) + marker + processedText.substring(end);
                offset += (compound.end - compound.start) - marker.length;
            });
            
            const words = processedText.split(/\s+/);
            const { person: subject, source } = detectSubject(words, 'french-to-conlang');
            
            let translation = [];
            let analysis = [];
            let grammarNotes = [];
            
            if (source === 'pronoun') grammarNotes.push(`Pronom "${subject}" d√©tect√©`);
            
            words.forEach(word => {
                const wordLower = word.toLowerCase();
                
                // Marqueurs d'expressions
                const markerMatch = markers.find(m => m.marker === word);
                if (markerMatch) {
                    translation.push(markerMatch.translation);
                    analysis.push({ 
                        original: markerMatch.original, 
                        translation: markerMatch.translation, 
                        type: markerMatch.type + ' (compos√©)' 
                    });
                    return;
                }
                
                // Lexique de base
                const basicEntry = Object.keys(basicLexicon).find(key => basicLexicon[key].fr.toLowerCase() === wordLower);
                if (basicEntry) {
                    translation.push(basicEntry);
                    analysis.push({ original: word, translation: basicEntry, type: basicLexicon[basicEntry].type });
                    return;
                }
                
                // Noms
                const nounEntry = Object.keys(nouns).find(key => nouns[key].fr.toLowerCase() === wordLower);
                if (nounEntry) {
                    translation.push(nounEntry);
                    analysis.push({ original: word, translation: nounEntry, type: 'nom' });
                    return;
                }
                
                // Verbes conjugu√©s fran√ßais ‚Üí nilfgaardien conjugu√©
                const verbInfo = findFrenchVerb(word);
                if (verbInfo) {
                    const nilfForm = conjugateNilfgaardian(verbInfo.nilfInfinitif, verbInfo.person, verbInfo.tense);
                    translation.push(nilfForm);
                    analysis.push({ 
                        original: word, 
                        translation: nilfForm, 
                        type: 'verbe (' + verbInfo.person + ', ' + verbInfo.tense + ')' 
                    });
                    grammarNotes.push(`Verbe "${word}" conjugu√© pour "${verbInfo.person}"`);
                    return;
                }
                
                // Infinitifs fran√ßais ‚Üí infinitifs nilfgaardiens
                const verbEntry = Object.keys(verbs).find(key => verbs[key].fr.toLowerCase() === wordLower);
                if (verbEntry) {
                    translation.push(verbEntry);
                    analysis.push({ original: word, translation: verbEntry, type: 'verbe (infinitif)' });
                    return;
                }
                
                // Inconnu
                translation.push(`[${word}]`);
                analysis.push({ original: word, translation: `[inconnu]`, type: 'inconnu' });
            });
            
            return { translation: translation.join(' '), analysis, grammar: grammarNotes };
        }

        // === INTERFACE ===
        function swapLanguages() {
            const inputLabel = document.getElementById('input-label');
            const outputLabel = document.getElementById('output-label');
            const inputText = document.getElementById('input-text');
            const outputText = document.getElementById('output-text');
            
            [inputLabel.textContent, outputLabel.textContent] = [outputLabel.textContent, inputLabel.textContent];
            [inputText.value, outputText.value] = [outputText.value, inputText.value];
            
            currentDirection = currentDirection === 'conlang-to-french' ? 'french-to-conlang' : 'conlang-to-french';
            document.querySelectorAll('.lang-option').forEach(btn => btn.classList.toggle('active'));
        }

        function translate() {
            const inputText = document.getElementById('input-text').value.trim();
            const outputText = document.getElementById('output-text');
            const analysis = document.getElementById('analysis');
            
            if (!inputText) return;

            let result;
            if (currentDirection === 'conlang-to-french') {
                result = translateToFrench(inputText);
            } else {
                result = translateToConlang(inputText);
            }
            
            outputText.value = result.translation;
            showAnalysis(result.analysis, result.grammar);
            analysis.style.display = 'block';
        }

        function showAnalysis(analysisData, grammarNotes) {
            const wordAnalysis = document.getElementById('word-analysis');
            const grammarDiv = document.getElementById('grammar-notes');
            
            wordAnalysis.innerHTML = '';
            analysisData.forEach(item => {
                const tag = document.createElement('div');
                tag.className = 'word-tag';
                tag.innerHTML = `<strong>${item.original}</strong> ‚Üí ${item.translation} <em>(${item.type})</em>`;
                wordAnalysis.appendChild(tag);
            });

            grammarDiv.innerHTML = grammarNotes ? 
                grammarNotes.map(note => `<div>üìù ${note}</div>`).join('') : '';
        }

        function loadDictionary() {
            const dictContent = document.getElementById('dictionary-content');
            
            // Expressions compos√©es
            const compounds = Object.keys(basicLexicon).filter(key => key.includes(' ') || key.includes('\''));
            if (compounds.length > 0) {
                const header = document.createElement('div');
                header.innerHTML = '<h4 style="color: #667eea;">EXPRESSIONS COMPOS√âES</h4>';
                dictContent.appendChild(header);
                
                compounds.forEach(word => {
                    const entry = document.createElement('div');
                    entry.className = 'dict-entry';
                    entry.innerHTML = `<strong>${word}</strong> ‚Üí ${basicLexicon[word].fr} <em>(${basicLexicon[word].type})</em>`;
                    dictContent.appendChild(entry);
                });
            }

            // Mots simples
            const simpleWords = Object.keys(basicLexicon).filter(key => !key.includes(' ') && !key.includes('\''));
            if (simpleWords.length > 0) {
                const header = document.createElement('div');
                header.innerHTML = '<h4 style="color: #667eea; margin-top: 15px;">MOTS SIMPLES</h4>';
                dictContent.appendChild(header);
                
                simpleWords.forEach(word => {
                    const entry = document.createElement('div');
                    entry.className = 'dict-entry';
                    entry.innerHTML = `<strong>${word}</strong> ‚Üí ${basicLexicon[word].fr} <em>(${basicLexicon[word].type})</em>`;
                    dictContent.appendChild(entry);
                });
            }
            
            // Noms
            if (Object.keys(nouns).length > 0) {
                const header = document.createElement('div');
                header.innerHTML = '<h4 style="color: #667eea; margin-top: 15px;">NOMS</h4>';
                dictContent.appendChild(header);
                
                Object.keys(nouns).forEach(word => {
                    const entry = document.createElement('div');
                    entry.className = 'dict-entry';
                    entry.innerHTML = `<strong>${word}</strong> ‚Üí ${nouns[word].fr} <em>(nom, ${nouns[word].gender_fr})</em>`;
                    dictContent.appendChild(entry);
                });
            }
            
            // Verbes
            if (Object.keys(verbs).length > 0) {
                const header = document.createElement('div');
                header.innerHTML = '<h4 style="color: #
                    667eea; margin-top: 15px;">VERBES</h4>';
                dictContent.appendChild(header);
                
                Object.keys(verbs).forEach(word => {
                    const entry = document.createElement('div');
                    entry.className = 'dict-entry';
                    entry.innerHTML = `<strong>${word}</strong> ‚Üí ${verbs[word].fr} <em>(radical: ${verbs[word].radical})</em>`;
                    dictContent.appendChild(entry);
                });
            }
        }

        // === √âV√âNEMENTS ===
        window.onload = function() {
            loadDictionary();
            translate(); // Traduction initiale
        };

        // Traduction automatique quand on tape
        document.getElementById('input-text').addEventListener('input', function() {
            translate();
        });

        // === FONCTIONS D'AJOUT DE VOCABULAIRE ===
        window.addExpression = function(nilfExpression, frenchExpression, type) {
            basicLexicon[nilfExpression] = { fr: frenchExpression, type: type };
            loadDictionary();
            console.log(`Expression ajout√©e: ${nilfExpression} ‚Üí ${frenchExpression} (${type})`);
        };

        window.addWord = function(nilfWord, frenchWord, type) {
            basicLexicon[nilfWord] = { fr: frenchWord, type: type };
            loadDictionary();
            console.log(`Mot ajout√©: ${nilfWord} ‚Üí ${frenchWord} (${type})`);
        };

        window.addNoun = function(nilfWord, frenchWord, genderFr, genderNilf) {
            nouns[nilfWord] = { fr: frenchWord, gender_fr: genderFr, gender_conlang: genderNilf };
            loadDictionary();
            console.log(`Nom ajout√©: ${nilfWord} ‚Üí ${frenchWord} (${genderFr})`);
        };

        window.addVerb = function(nilfInfinitif, radical, frenchInfinitif) {
            verbs[nilfInfinitif] = { radical: radical, fr: frenchInfinitif };
            loadDictionary();
            console.log(`Verbe ajout√©: ${nilfInfinitif} (${radical}) ‚Üí ${frenchInfinitif}`);
        };
    </script>
</body>
</html>
