<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traducteur de Langue Construite</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh; padding: 20px;
        }
        .container {
            max-width: 1000px; margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px; box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        .header { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; text-align: center; padding: 30px; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .translator-section { padding: 40px; }
        .language-selector { display: flex; justify-content: center; align-items: center; margin-bottom: 30px; gap: 20px; }
        .lang-option { background: #f8f9fa; border: 2px solid #e9ecef; border-radius: 15px; padding: 15px 25px; cursor: pointer; font-weight: 600; }
        .lang-option.active { background: linear-gradient(135deg, #667eea, #764ba2); color: white; }
        .swap-btn { background: linear-gradient(135deg, #ff6b6b, #feca57); border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; color: white; font-size: 20px; }
        .translation-area { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 30px; }
        textarea { width: 100%; height: 150px; border: 2px solid #e9ecef; border-radius: 15px; padding: 20px; font-size: 16px; resize: none; }
        .translate-btn { display: block; width: 200px; margin: 20px auto; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 25px; padding: 15px 30px; font-size: 16px; cursor: pointer; }
        .analysis { background: #f8f9fa; border-radius: 15px; padding: 20px; margin-top: 20px; display: none; }
        .word-tag { background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 5px 10px; margin: 5px; display: inline-block; font-size: 14px; }
        .dictionary { background: #fff; border-radius: 15px; padding: 20px; margin-top: 30px; border: 1px solid #e9ecef; }
        .dict-entry { padding: 8px 0; border-bottom: 1px solid #f1f3f4; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚ú® Traducteur de Langue Construite ‚ú®</h1>
            <p>Syst√®me automatique avec conjugaisons intelligentes</p>
        </div>
        <div class="translator-section">
            <div class="language-selector">
                <div class="lang-option active">Votre Langue</div>
                <button class="swap-btn" onclick="swapLanguages()">‚áÑ</button>
                <div class="lang-option">Fran√ßais</div>
            </div>
            <div class="translation-area">
                <div>
                    <h3 id="input-label">Votre Langue</h3>
                    <textarea id="input-text" placeholder="Saisissez votre texte ici...">Skel gorval drae'skorr grurnir osk kravnyar nork</textarea>
                </div>
                <div>
                    <h3 id="output-label">Fran√ßais</h3>
                    <textarea id="output-text" placeholder="La traduction appara√Ætra ici..." readonly></textarea>
                </div>
            </div>
            <button class="translate-btn" onclick="translate()">üîÑ Traduire</button>
            <div class="analysis" id="analysis">
                <h4>üìã Analyse Grammaticale</h4>
                <div id="word-analysis"></div>
                <div id="grammar-notes"></div>
            </div>
            <div class="dictionary">
                <h3>üìö Dictionnaire</h3>
                <div id="dictionary-content"></div>
            </div>
        </div>
    </div>

    <script>
        // Dictionnaire de base √©tendu
        const basicLexicon = {
            'skel': { fr: 'la', type: 'article' },
            'osk': { fr: 'mais', type: 'conjonction' },
            'drae\'skorr': { fr: 'sauvage', type: 'adjectif' },
            'nork': { fr: 'ne...pas', type: 'n√©gation' },
            // Adverbes/Pr√©positions/Conjonctions
            'a': { fr: 'vers', type: 'pr√©position' },
            'aen': { fr: 'pour', type: 'pr√©position' },
            'aep': { fr: 'sur', type: 'pr√©position' },
            'hwre': { fr: 'ici', type: 'adverbe' },
            'na': { fr: 'ou', type: 'conjonction' },
            'namyn': { fr: 'sauf', type: 'pr√©position' },
            'ne√©n': { fr: 'non', type: 'adverbe' },
            'veldi': { fr: 'tr√®s', type: 'adverbe' },
            'vort': { fr: 'loin', type: 'adverbe' },
            'y': { fr: 'et', type: 'conjonction' },
            'yn': { fr: 'dans', type: 'pr√©position' },
            'var\'oom': { fr: 'pourquoi', type: 'interrogatif' },
            // Pronoms/D√©terminants
            'eve': { fr: 'tout', type: 'pronom' },
            'evelienn': { fr: 'tout le monde', type: 'pronom' },
            'thu': { fr: 'tu', type: 'pronom' },
            'uav': { fr: 'ton', type: 'd√©terminant' },
            'visse': { fr: 'vous', type: 'pronom' },
            'que': { fr: 'que', type: 'interrogatif' },
            'qua': { fr: 'quoi', type: 'interrogatif' },
            'que\'ess': { fr: 'combien', type: 'interrogatif' },
            // Interjections/Formules
            'awr': { fr: 'monsieur', type: 'formule' },
            'hael': { fr: 'salut', type: 'formule' },
            'squesse': { fr: 'excusez-moi', type: 'formule' },
            'taing': { fr: 'merci', type: 'formule' },
            'va faill': { fr: 'au revoir', type: 'formule' },
            // Adjectifs
            'adhart': { fr: 'en avant', type: 'adjectif' },
            'ard': { fr: 'grand', type: 'adjectif' },
            'bloedar': { fr: 'sanglant', type: 'adjectif' },
            'calm': { fr: 'calme', type: 'adjectif' },
            'eigean': { fr: 'n√©cessaire', type: 'adjectif' },
            'geehaet': { fr: 'dur', type: 'adjectif' },
            'gvaedyn': { fr: 'tenace', type: 'adjectif' },
            'gvaelded': { fr: 'assoiff√© de sang', type: 'adjectif' },
            'hen': { fr: 'vieux', type: 'adjectif' },
            'math': { fr: 'bien', type: 'adjectif' },
            'tana': { fr: 'profond', type: 'adjectif' },
            'tanalach': { fr: 'peu profond', type: 'adjectif' },
            'velo√´': { fr: 'rapide', type: 'adjectif' },
            'wen': { fr: 'blanc', type: 'adjectif' },
            'esse\'lath': { fr: 'l√¢che', type: 'adjectif' }
        };

        // Noms avec genres (tous d√©finis comme masculin/f√©minin par d√©faut)
        const nouns = {
            'gorval': { fr: 'b√™te', gender_fr: 'f', gender_conlang: 'm' },
            'mithel': { fr: 'chat', gender_fr: 'm', gender_conlang: 'f' },
            // Nouveaux noms
            'allaidh': { fr: 'barbares', gender_fr: 'm', gender_conlang: 'm' },
            'arse': { fr: 'cul', gender_fr: 'm', gender_conlang: 'm' },
            '√°th': { fr: 'oeil', gender_fr: 'm', gender_conlang: 'm' },
            'a\'vean': { fr: 'porte', gender_fr: 'f', gender_conlang: 'f' },
            'beist': { fr: 'animal', gender_fr: 'm', gender_conlang: 'm' },
            'beseta': { fr: 'pince √† √©piler', gender_fr: 'f', gender_conlang: 'f' },
            'bhampair': { fr: 'vampire', gender_fr: 'm', gender_conlang: 'm' },
            'bleidd': { fr: 'loup', gender_fr: 'm', gender_conlang: 'm' },
            'bu\'rac': { fr: 'plouc', gender_fr: 'm', gender_conlang: 'm' },
            'caer': { fr: 'terre', gender_fr: 'f', gender_conlang: 'f' },
            'carn': { fr: 'tertre', gender_fr: 'm', gender_conlang: 'm' },
            'ceas\'raet': { fr: 'empire', gender_fr: 'm', gender_conlang: 'm' },
            'creasa': { fr: 'devoir', gender_fr: 'm', gender_conlang: 'm' },
            'cuan': { fr: 'prostitu√©e', gender_fr: 'f', gender_conlang: 'f' },
            'cyrche': { fr: 'attaquant', gender_fr: 'm', gender_conlang: 'm' },
            'daerienn': { fr: 'sorcier', gender_fr: 'm', gender_conlang: 'm' },
            'deith': { fr: 'flamme', gender_fr: 'f', gender_conlang: 'f' },
            'deithwen': { fr: 'flamme blanche', gender_fr: 'f', gender_conlang: 'f' },
            'd√≤chas': { fr: 'espoir', gender_fr: 'm', gender_conlang: 'm' },
            'd\'yaebl': { fr: 'diable', gender_fr: 'm', gender_conlang: 'm' },
            'e\'er': { fr: 'honneur', gender_fr: 'm', gender_conlang: 'm' },
            'eisio': { fr: 'glace', gender_fr: 'f', gender_conlang: 'f' },
            'esse': { fr: 'volont√©', gender_fr: 'f', gender_conlang: 'f' },
            'ess\'spaet': { fr: 'crachat', gender_fr: 'm', gender_conlang: 'm' },
            'evgyr': { fr: 'maintenant', gender_fr: 'm', gender_conlang: 'm' },
            'evn\'gesaen': { fr: 'ambassadeur', gender_fr: 'm', gender_conlang: 'm' },
            'feainn': { fr: 'soleil', gender_fr: 'm', gender_conlang: 'm' },
            'fion': { fr: 'vin', gender_fr: 'm', gender_conlang: 'm' },
            'fydd': { fr: 'passage', gender_fr: 'm', gender_conlang: 'm' },
            'gaedeen': { fr: 'fait', gender_fr: 'm', gender_conlang: 'm' },
            'g√†rdan': { fr: 'gardes', gender_fr: 'f', gender_conlang: 'm' },
            'ge\'erillan': { fr: 'gu√©rillas', gender_fr: 'f', gender_conlang: 'm' },
            'gl√°eddyv': { fr: '√©p√©e', gender_fr: 'f', gender_conlang: 'f' },
            'gl√≤ir': { fr: 'gloire', gender_fr: 'f', gender_conlang: 'f' },
            'glys': { fr: 'rivi√®re', gender_fr: 'f', gender_conlang: 'f' },
            'gr√¨ffean': { fr: 'griffon', gender_fr: 'm', gender_conlang: 'm' },
            'hanse': { fr: 'hanse', gender_fr: 'f', gender_conlang: 'f' },
            'havfrue': { fr: 'sir√®ne', gender_fr: 'f', gender_conlang: 'f' },
            'heet': { fr: 'fi√®vre', gender_fr: 'f', gender_conlang: 'f' },
            'hoersoon': { fr: 'fils de pute', gender_fr: 'm', gender_conlang: 'm' },
            'il\'edrith': { fr: 'magie', gender_fr: 'f', gender_conlang: 'f' },
            'il\'edrithean': { fr: 'mage', gender_fr: 'm', gender_conlang: 'm' },
            'inis': { fr: '√Æle', gender_fr: 'f', gender_conlang: 'f' },
            'iss\'kund': { fr: 'm√©decine', gender_fr: 'f', gender_conlang: 'f' },
            'iss\'ra': { fr: 'esclave', gender_fr: 'm', gender_conlang: 'm' },
            'jakkten': { fr: 'chasse', gender_fr: 'f', gender_conlang: 'f' },
            'joc': { fr: 'blague', gender_fr: 'f', gender_conlang: 'f' },
            'Ker\'zaer': { fr: 'empereur', gender_fr: 'm', gender_conlang: 'm' },
            'kroofeir': { fr: 'meule de foin', gender_fr: 'f', gender_conlang: 'f' },
            'kusse': { fr: 'vagin', gender_fr: 'm', gender_conlang: 'm' },
            'laeke': { fr: 'lac', gender_fr: 'm', gender_conlang: 'm' },
            'larwm': { fr: 'aide', gender_fr: 'f', gender_conlang: 'f' },
            'luned': { fr: 'fille', gender_fr: 'f', gender_conlang: 'f' },
            'Lyrien': { fr: 'Lyrien', gender_fr: 'm', gender_conlang: 'm' },
            'maerche': { fr: 'femme', gender_fr: 'f', gender_conlang: 'f' },
            'moera': { fr: 'marais', gender_fr: 'm', gender_conlang: 'm' },
            'morvud': { fr: 'ennemi', gender_fr: 'm', gender_conlang: 'm' },
            'niss': { fr: 'aisselles', gender_fr: 'f', gender_conlang: 'f' },
            'nordlingaen': { fr: 'Nordien', gender_fr: 'm', gender_conlang: 'm' },
            'nyald': { fr: 'aiguille', gender_fr: 'f', gender_conlang: 'f' },
            'pest': { fr: 'peste', gender_fr: 'f', gender_conlang: 'f' },
            'pund': { fr: 'vomi', gender_fr: 'm', gender_conlang: 'm' },
            'orde': { fr: 'ordre', gender_fr: 'm', gender_conlang: 'm' },
            'raet': { fr: 'pays', gender_fr: 'm', gender_conlang: 'm' },
            'rechta': { fr: 'verdict', gender_fr: 'm', gender_conlang: 'm' },
            'rotsaak': { fr: 'salopard', gender_fr: 'm', gender_conlang: 'm' },
            's√†bh': { fr: 'scie', gender_fr: 'f', gender_conlang: 'f' },
            'se\'ege': { fr: 'victoire', gender_fr: 'f', gender_conlang: 'f' },
            'sei√¢\'fyll': { fr: 'formation', gender_fr: 'f', gender_conlang: 'f' },
            'strigea': { fr: 'strige', gender_fr: 'f', gender_conlang: 'f' },
            'stronthe': { fr: 'merde', gender_fr: 'f', gender_conlang: 'f' },
            'tedd': { fr: 'temps', gender_fr: 'm', gender_conlang: 'm' },
            'tr√≤cair': { fr: 'piti√©', gender_fr: 'f', gender_conlang: 'f' },
            'toorean': { fr: 'col√®re', gender_fr: 'f', gender_conlang: 'f' },
            'tuv\'en': { fr: 'mort', gender_fr: 'f', gender_conlang: 'f' },
            'twe': { fr: 'deux', gender_fr: 'm', gender_conlang: 'm' },
            'ulf\'heida': { fr: 'monstre', gender_fr: 'm', gender_conlang: 'm' },
            'va\'en': { fr: 'voyage', gender_fr: 'm', gender_conlang: 'm' },
            'vaerb\'tinnea': { fr: 'bonne volont√©', gender_fr: 'f', gender_conlang: 'f' },
            'vaer\'truov': { fr: 'espoir', gender_fr: 'm', gender_conlang: 'm' },
            'vatt\'ghern': { fr: 'sorceleur', gender_fr: 'm', gender_conlang: 'm' },
            'verloos': { fr: 'perte', gender_fr: 'f', gender_conlang: 'f' },
            'v√πtter': { fr: 'eau', gender_fr: 'f', gender_conlang: 'f' },
            'zaighdera': { fr: 'bataillon', gender_fr: 'm', gender_conlang: 'm' },
            'z√®amach': { fr: 'avertissement', gender_fr: 'm', gender_conlang: 'm' }
        };

        // Verbes avec radicaux - √âNORM√âMENT √©tendus !
        const verbs = {
            'grurnir': { radical: 'grurn', fr: 'grogner' },
            'kravnyar': { radical: 'kravny', fr: 'mordre' },
            'addan': { radical: 'add', fr: 'danser' },
            'gleith': { radical: 'glei', fr: 'savoir' },
            // Nouveaux verbes
            'a√¢\'anval': { radical: 'a√¢\'anv', fr: 'attaquer' },
            'aec√°emm': { radical: 'aec√°e', fr: 'suivre' },
            'aedragh': { radical: 'aedrag', fr: 'provoquer' },
            'claidheamh': { radical: 'claidhea', fr: 'rengainer' },
            'creasan': { radical: 'creas', fr: 'devoir' },
            'daar\'tocht': { radical: 'daar\'toc', fr: 'conspirer' },
            'deien': { radical: 'dei', fr: 'servir' },
            'eigean': { radical: 'eig', fr: 'falloir' },
            'ess': { radical: 'ess', fr: '√™tre' },
            'hvren': { radical: 'hvr', fr: 'tuer' },
            'iarean': { radical: 'iare', fr: 'chercher' },
            'laddhe': { radical: 'laddh', fr: 'tuer' },
            'mire': { radical: 'mir', fr: 'regarder' },
            'mare': { radical: 'mar', fr: 'voir' },
            'morv': { radical: 'morv', fr: 'mourir' },
            'rach': { radical: 'rach', fr: 'bouger' },
            'ratreut': { radical: 'ratreut', fr: 'fuir' },
            'var': { radical: 'var', fr: 'aller' },
            'vaer\'truov': { radical: 'vaer\'tr', fr: 'esp√©rer' },
            'vedren': { radical: 'vedr', fr: 'tenir' }
        };

        let currentDirection = 'conlang-to-french';

        // Conjugaisons nilfgaardiennes par temps
        const nilf_endings = {
            pr√©sent: { 'je': 'en', 'tu': 'es', 'il': '', 'elle': '', 'nous': 'avam', 'vous': 'avel', 'ils': 'arin', 'elles': 'arin' },
            futur: { 'je': 'rash', 'tu': 'resh', 'il': 'rin', 'elle': 'rin', 'nous': 'ravam', 'vous': 'ravel', 'ils': 'ranim', 'elles': 'ranim' },
            imparfait: { 'je': 'ien', 'tu': 'ias', 'il': 'ier', 'elle': 'ier', 'nous': 'iavem', 'vous': 'iavel', 'ils': 'iarn', 'elles': 'iarn' }
        };

// GROUPES DE VERBES FRAN√áAIS
const frenchVerbGroups = {
    // 1er groupe (-er) - terminaisons r√©guli√®res
    group1: {
        endings: { je: 'e', tu: 'es', il: 'e', elle: 'e', nous: 'ons', vous: 'ez', ils: 'ent', elles: 'ent' },
        verbs: ['danser', 'attaquer', 'chercher', 'regarder', 'provoquer', 'esp√©rer', 'conspirer', 'rengainer']
    },
    
    // 2√®me groupe (-ir r√©guliers)
    group2: {
        endings: { je: 'is', tu: 'is', il: 'it', elle: 'it', nous: 'issons', vous: 'issez', ils: 'issent', elles: 'issent' },
        verbs: []
    },
    
    // 3√®me groupe (-ir irr√©guliers, -oir, -re)
    group3: {
        // Pas de terminaisons fixes, chaque verbe est d√©fini individuellement
        verbs: ['servir', 'tenir', 'mourir', 'voir', 'suivre', 'mordre']
    },
    
    // Verbes compl√®tement irr√©guliers
    irregular: {
        verbs: ['√™tre', 'avoir', 'aller', 'faire', 'dire', 'savoir', 'grogner']
    }
};

        // Conjugaisons fran√ßaises simplifi√©es mais compl√®tes
        function conjugateFrench(infinitif, person, tense = 'pr√©sent') {
    // V√©rifier dans quel groupe est le verbe
    for (const [groupName, groupData] of Object.entries(frenchVerbGroups)) {
        if (groupData.verbs && groupData.verbs.includes(infinitif)) {
            
            // Groupe 1 (verbes en -er r√©guliers)
            if (groupName === 'group1') {
                const radical = infinitif.slice(0, -2);
                return radical + (groupData.endings[person] || '');
            }
            
            // Groupe 2 (verbes en -ir r√©guliers)
            if (groupName === 'group2') {
                const radical = infinitif.slice(0, -2);
                return radical + (groupData.endings[person] || '');
            }
            
            // Groupe 3 et irr√©guliers - cas par cas
            if (infinitif === 'grogner') {
                const forms = { je: 'grogne', tu: 'grognes', il: 'grogne', elle: 'grogne', nous: 'grognons', vous: 'grognez', ils: 'grognent', elles: 'grognent' };
                return forms[person] || infinitif;
            }
            if (infinitif === 'mordre') {
                const forms = { je: 'mords', tu: 'mords', il: 'mord', elle: 'mord', nous: 'mordons', vous: 'mordez', ils: 'mordent', elles: 'mordent' };
                return forms[person] || infinitif;
            }
            if (infinitif === '√™tre') {
                const forms = { je: 'suis', tu: 'es', il: 'est', elle: 'est', nous: 'sommes', vous: '√™tes', ils: 'sont', elles: 'sont' };
                return forms[person] || infinitif;
            }
            if (infinitif === 'voir') {
                const forms = { je: 'vois', tu: 'vois', il: 'voit', elle: 'voit', nous: 'voyons', vous: 'voyez', ils: 'voient', elles: 'voient' };
                return forms[person] || infinitif;
            }
            if (infinitif === 'aller') {
                const forms = { je: 'vais', tu: 'vas', il: 'va', elle: 'va', nous: 'allons', vous: 'allez', ils: 'vont', elles: 'vont' };
                return forms[person] || infinitif;
            }
            if (infinitif === 'savoir') {
                const forms = { je: 'sais', tu: 'sais', il: 'sait', elle: 'sait', nous: 'savons', vous: 'savez', ils: 'savent', elles: 'savent' };
                return forms[person] || infinitif;
            }
            if (infinitif === 'servir') {
                const forms = { je: 'sers', tu: 'sers', il: 'sert', elle: 'sert', nous: 'servons', vous: 'servez', ils: 'servent', elles: 'servent' };
                return forms[person] || infinitif;
            }
            if (infinitif === 'tenir') {
                const forms = { je: 'tiens', tu: 'tiens', il: 'tient', elle: 'tient', nous: 'tenons', vous: 'tenez', ils: 'tiennent', elles: 'tiennent' };
                return forms[person] || infinitif;
            }
            if (infinitif === 'suivre') {
                const forms = { je: 'suis', tu: 'suis', il: 'suit', elle: 'suit', nous: 'suivons', vous: 'suivez', ils: 'suivent', elles: 'suivent' };
                return forms[person] || infinitif;
            }
            
            // Si on arrive ici, le verbe est dans un groupe mais pas encore d√©fini
            return infinitif;
        }
    }
    
    // Si le verbe n'est dans aucun groupe, essayer le groupe 1 par d√©faut pour les -er
    if (infinitif.endsWith('er')) {
        const radical = infinitif.slice(0, -2);
        const endings = frenchVerbGroups.group1.endings;
        return radical + (endings[person] || '');
    }
    
    return infinitif;
}
            
            const ending = nilf_endings[tense] ? nilf_endings[tense][person] : '';
            return verb.radical + ending;
        }

        function findFrenchVerb(conjugatedForm) {
            for (const [infinitif, verbData] of Object.entries(verbs)) {
                for (const tense of ['pr√©sent', 'futur', 'imparfait']) {
                    for (const person of ['je', 'tu', 'il', 'elle', 'nous', 'vous', 'ils', 'elles']) {
                        const frenchForm = conjugateFrench(verbData.fr, person, tense);
                        if (frenchForm === conjugatedForm) {
                            return { infinitif: verbData.fr, person: person, nilfInfinitif: infinitif, tense: tense };
                        }
                    }
                }
            }
            return null;
        }

        function detectSubject(words, direction) {
            if (direction === 'french-to-conlang') {
                const pronouns = ['je', 'tu', 'il', 'elle', 'nous', 'vous', 'ils', 'elles'];
                for (const word of words) {
                    if (pronouns.includes(word)) {
                        return { person: word, source: 'pronoun' };
                    }
                }
                
                for (const word of words) {
                    const noun = Object.values(nouns).find(n => n.fr === word);
                    if (noun) {
                        return { person: noun.gender_conlang === 'm' ? 'il' : 'elle', source: 'noun', noun: word };
                    }
                }
                
                for (const word of words) {
                    const verbInfo = findFrenchVerb(word);
                    if (verbInfo) {
                        return { person: verbInfo.person, source: 'verb', verb: word };
                    }
                }
            } else {
                for (const word of words) {
                    const noun = nouns[word];
                    if (noun) {
                        return { person: noun.gender_fr === 'm' ? 'il' : 'elle', source: 'noun', noun: word };
                    }
                }
            }
            
            return { person: 'il', source: 'default' };
        }

        // D√©tection des temps compos√©s
        function detectCompoundTense(words) {
            let result = [];
            let i = 0;
            
            while (i < words.length) {
                if (['ai', 'as', 'a', 'avons', 'avez', 'ont'].includes(words[i])) {
                    if (i + 1 < words.length) {
                        result.push({ type: 'pass√©_compos√©', auxiliary: words[i], verb: words[i + 1], span: 2 });
                        i += 2;
                        continue;
                    }
                }
                
                if (['vais', 'vas', 'va', 'allons', 'allez', 'vont'].includes(words[i])) {
                    if (i + 1 < words.length) {
                        const nextWord = words[i + 1];
                        if (nextWord.endsWith('er') || nextWord.endsWith('ir') || nextWord.endsWith('re')) {
                            result.push({ type: 'futur_proche', auxiliary: words[i], verb: words[i + 1], span: 2 });
                            i += 2;
                            continue;
                        }
                    }
                }
                
                result.push({ type: 'normal', word: words[i], span: 1 });
                i++;
            }
            
            return result;
        }

        function getParticiple(infinitive) {
            const irregulars = { 'prendre': 'pris', 'faire': 'fait', 'dire': 'dit', 'voir': 'vu', 'savoir': 'su' };
            if (irregulars[infinitive]) return irregulars[infinitive];
            if (infinitive.endsWith('er')) return infinitive.slice(0, -2) + '√©';
            if (infinitive.endsWith('ir')) return infinitive.slice(0, -2) + 'i';
            return infinitive + '√©';
        }

        function participleToInfinitive(participle) {
            if (participle.endsWith('√©')) return participle.slice(0, -1) + 'er';
            const irregulars = { 'pris': 'prendre', 'fait': 'faire', 'dit': 'dire', 'vu': 'voir', 'su': 'savoir' };
            return irregulars[participle] || participle;
        }

        // Traduction fran√ßais ‚Üí nilfgaardien
function translateToConlang(text) {
    // 1. D'abord traiter les expressions compos√©es fran√ßaises (PRIORIT√â)
    let processedText = text;
    let translation = [];
    let analysis = [];
    let grammarNotes = [];
    
    // Chercher toutes les expressions fran√ßaises compos√©es dans basicLexicon et nouns
    const allFrenchExpressions = [];
    
    // Chercher dans basicLexicon
    Object.keys(basicLexicon).forEach(key => {
        if (basicLexicon[key].fr.includes(' ')) {
            allFrenchExpressions.push({
                french: basicLexicon[key].fr,
                nilfgaardian: key,
                type: basicLexicon[key].type
            });
        }
    });
    
    // Chercher dans nouns
    Object.keys(nouns).forEach(key => {
        if (nouns[key].fr.includes(' ')) {
            allFrenchExpressions.push({
                french: nouns[key].fr,
                nilfgaardian: key,
                type: 'nom'
            });
        }
    });
    
    // Trier par longueur d√©croissante (expressions les plus longues d'abord)
    allFrenchExpressions.sort((a, b) => b.french.length - a.french.length);
    
    // Remplacer les expressions trouv√©es par des marqueurs
    const markers = [];
    allFrenchExpressions.forEach((expr, index) => {
        const regex = new RegExp('\\b' + expr.french.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'gi');
        if (regex.test(processedText)) {
            const marker = `__EXPR_${index}__`;
            markers.push({
                marker: marker,
                original: expr.french,
                translation: expr.nilfgaardian,
                type: expr.type
            });
            processedText = processedText.replace(regex, marker);
        }
    });
    
    // 2. Traiter le texte mot par mot
    const words = processedText.toLowerCase().split(/\s+/);
    const { person: subject, source } = detectSubject(words, 'french-to-conlang');
    
    if (source === 'pronoun') grammarNotes.push(`Pronom "${subject}" d√©tect√©`);
    
    const compoundTenses = detectCompoundTense(words);
    
    compoundTenses.forEach(item => {
        if (item.type === 'pass√©_compos√©') {
            const infinitive = participleToInfinitive(item.verb);
            const nilfInfinitive = Object.keys(verbs).find(key => verbs[key].fr === infinitive);
            
            if (nilfInfinitive) {
                translation.push(`vaar ${nilfInfinitive}`);
                analysis.push({ original: `${item.auxiliary} ${item.verb}`, translation: `vaar ${nilfInfinitive}`, type: 'pass√©_compos√©' });
                grammarNotes.push(`Pass√© compos√© d√©tect√©: "${item.auxiliary} ${item.verb}" ‚Üí vaar + infinitif`);
            } else {
                translation.push(`vaar [${item.verb}]`);
                analysis.push({ original: `${item.auxiliary} ${item.verb}`, translation: `vaar [${item.verb}]`, type: 'pass√©_compos√© (verbe inconnu)' });
            }
        } else if (item.type === 'futur_proche') {
            const nilfInfinitive = Object.keys(verbs).find(key => verbs[key].fr === item.verb);
            
            if (nilfInfinitive) {
                translation.push(`voor ${nilfInfinitive}`);
                analysis.push({ original: `${item.auxiliary} ${item.verb}`, translation: `voor ${nilfInfinitive}`, type: 'futur_proche' });
                grammarNotes.push(`Futur proche d√©tect√©: "${item.auxiliary} ${item.verb}" ‚Üí voor + infinitif`);
            } else {
                translation.push(`voor [${item.verb}]`);
                analysis.push({ original: `${item.auxiliary} ${item.verb}`, translation: `voor [${item.verb}]`, type: 'futur_proche (verbe inconnu)' });
            }
        } else {
            const word = item.word;
            
            // V√©rifier si c'est un marqueur d'expression compos√©e
            const markerMatch = markers.find(m => m.marker === word);
            if (markerMatch) {
                translation.push(markerMatch.translation);
                analysis.push({ 
                    original: markerMatch.original, 
                    translation: markerMatch.translation, 
                    type: markerMatch.type + ' (expression compos√©e)' 
                });
                return;
            }
            
            const basicEntry = Object.keys(basicLexicon).find(key => basicLexicon[key].fr === word);
            if (basicEntry) {
                translation.push(basicEntry);
                analysis.push({ original: word, translation: basicEntry, type: basicLexicon[basicEntry].type });
                return;
            }
            
            const nounEntry = Object.keys(nouns).find(key => nouns[key].fr === word);
            if (nounEntry) {
                translation.push(nounEntry);
                analysis.push({ original: word, translation: nounEntry, type: 'nom' });
                return;
            }
            
            const verbEntry = findFrenchVerb(word);
            if (verbEntry) {
                const nilfForm = conjugateNilfgaardian(verbEntry.nilfInfinitif, subject, verbEntry.tense);
                translation.push(nilfForm);
                analysis.push({ original: word, translation: nilfForm, type: 'verbe (' + subject + ', ' + verbEntry.tense + ')' });
                grammarNotes.push(`Verbe "${word}" conjugu√© pour "${subject}" au ${verbEntry.tense}`);
                return;
            }
            
            translation.push(`[${word}]`);
            analysis.push({ original: word, translation: `[inconnu]`, type: 'inconnu' });
        }
    });
    
    return { translation: translation.join(' '), analysis, grammar: grammarNotes };
}
            // Traduction nilfgaardien ‚Üí fran√ßais
function translateToFrench(text) {
    const words = text.split(/\s+/);
    
    // D'abord chercher les expressions compos√©es dans le texte original
    const compoundMatches = [];
    const textLower = text.toLowerCase();
    
    // Chercher toutes les expressions dans basicLexicon et nouns
    const allExpressions = [];
    Object.keys(basicLexicon).forEach(key => {
        if (key.includes(' ') || key.includes('\'')) {
            allExpressions.push({ key: key, translation: basicLexicon[key].fr, type: basicLexicon[key].type });
        }
    });
    Object.keys(nouns).forEach(key => {
        if (key.includes(' ') || key.includes('\'')) {
            allExpressions.push({ key: key, translation: nouns[key].fr, type: 'nom' });
        }
    });
    
    // Trier par longueur d√©croissante
    allExpressions.sort((a, b) => b.key.length - a.key.length);
    
    // Marquer les expressions trouv√©es
    allExpressions.forEach(expr => {
        const index = textLower.indexOf(expr.key.toLowerCase());
        if (index !== -1) {
            const before = index === 0 || /\s/.test(textLower[index - 1]);
            const after = index + expr.key.length === textLower.length || /\s/.test(textLower[index + expr.key.length]);
            
            if (before && after) {
                compoundMatches.push({
                    start: index,
                    end: index + expr.key.length,
                    original: text.substring(index, index + expr.key.length),
                    translation: expr.translation,
                    type: expr.type
                });
            }
        }
    });
    
    // Si on a trouv√© des expressions compos√©es, les traiter en priorit√©
    if (compoundMatches.length > 0) {
        let translation = [];
        let analysis = [];
        compoundMatches.forEach(match => {
            translation.push(match.translation);
            analysis.push({
                original: match.original,
                translation: match.translation,
                type: match.type + ' (expression compos√©e)'
            });
        });
        return { translation: translation.join(' '), analysis, grammar: [] };
    }

    // Sinon, traiter mot par mot
    const { person: subject } = detectSubject(words, 'conlang-to-french');
    let translation = [];
    let analysis = [];
    let grammarNotes = [];
    
    let processedWords = [];
    let i = 0;
    while (i < words.length) {
        if (i < words.length - 1 && words[i + 1] === 'nork') {
            processedWords.push({ word: words[i], negated: true });
            i += 2;
        } else {
            processedWords.push({ word: words[i], negated: false });
            i++;
        }
    }
    
    let skipNext = false;
    processedWords.forEach(({ word, negated }, index) => {
        if (skipNext) { skipNext = false; return; }
        
        if (word === 'vaar' && index + 1 < processedWords.length && verbs[processedWords[index + 1].word]) {
            const nextWord = processedWords[index + 1].word;
            const verb = verbs[nextWord];
            const participle = getParticiple(verb.fr);
            let frenchForm = `a ${participle}`;
            if (negated) frenchForm = `n'a pas ${participle}`;
            
            translation.push(frenchForm);
            analysis.push({ original: `${word} ${nextWord}`, translation: frenchForm, type: 'pass√©_compos√©' });
            skipNext = true;
            return;
        }
        
        if (word === 'voor' && index + 1 < processedWords.length && verbs[processedWords[index + 1].word]) {
            const nextWord = processedWords[index + 1].word;
            const verb = verbs[nextWord];
            let frenchForm = `va ${verb.fr}`;
            if (negated) frenchForm = `ne va pas ${verb.fr}`;
            
            translation.push(frenchForm);
            analysis.push({ original: `${word} ${nextWord}`, translation: frenchForm, type: 'futur_proche' });
            skipNext = true;
            return;
        }
        
        const basicEntry = Object.keys(basicLexicon).find(key => key.toLowerCase() === word.toLowerCase());
        if (basicEntry) {
            translation.push(basicLexicon[basicEntry].fr);
            analysis.push({ original: word, translation: basicLexicon[basicEntry].fr, type: basicLexicon[basicEntry].type });
            return;
        }
        
        const nounEntry = Object.keys(nouns).find(key => key.toLowerCase() === word.toLowerCase());
        if (nounEntry) {
            translation.push(nouns[nounEntry].fr);
            analysis.push({ original: word, translation: nouns[nounEntry].fr, type: 'nom' });
            return;
        }
        
        const verbEntry = Object.keys(verbs).find(key => key.toLowerCase() === word.toLowerCase());
        if (verbEntry) {
            let frenchForm = conjugateFrench(verbs[verbEntry].fr, subject, 'pr√©sent');
            if (negated) {
                frenchForm = 'ne ' + frenchForm + ' pas';
                grammarNotes.push(`N√©gation appliqu√©e √† "${word}"`);
            }
            translation.push(frenchForm);
            analysis.push({ original: word + (negated ? ' nork' : ''), translation: frenchForm, type: 'verbe (' + subject + ', pr√©sent)' });
            return;
        }
        
        translation.push(`[${word}]`);
        analysis.push({ original: word, translation: `[inconnu]`, type: 'inconnu' });
    });
    
    return { translation: translation.join(' '), analysis, grammar: grammarNotes };
}
        // Traduction fran√ßais ‚Üí nilfgaardien
        function translateToConlang(text) {
            const words = text.toLowerCase().split(/\s+/);
            const { person: subject, source } = detectSubject(words, 'french-to-conlang');
            
            let translation = [];
            let analysis = [];
            let grammarNotes = [];
            
            if (source === 'pronoun') grammarNotes.push(`Pronom "${subject}" d√©tect√©`);
            
            const compoundTenses = detectCompoundTense(words);
            
            compoundTenses.forEach(item => {
                if (item.type === 'pass√©_compos√©') {
                    const infinitive = participleToInfinitive(item.verb);
                    const nilfInfinitive = Object.keys(verbs).find(key => verbs[key].fr === infinitive);
                    
                    if (nilfInfinitive) {
                        translation.push(`vaar ${nilfInfinitive}`);
                        analysis.push({ original: `${item.auxiliary} ${item.verb}`, translation: `vaar ${nilfInfinitive}`, type: 'pass√©_compos√©' });
                        grammarNotes.push(`Pass√© compos√© d√©tect√©: "${item.auxiliary} ${item.verb}" ‚Üí vaar + infinitif`);
                    } else {
                        translation.push(`vaar [${item.verb}]`);
                        analysis.push({ original: `${item.auxiliary} ${item.verb}`, translation: `vaar [${item.verb}]`, type: 'pass√©_compos√© (verbe inconnu)' });
                    }
                } else if (item.type === 'futur_proche') {
                    const nilfInfinitive = Object.keys(verbs).find(key => verbs[key].fr === item.verb);
                    
                    if (nilfInfinitive) {
                        translation.push(`voor ${nilfInfinitive}`);
                        analysis.push({ original: `${item.auxiliary} ${item.verb}`, translation: `voor ${nilfInfinitive}`, type: 'futur_proche' });
                        grammarNotes.push(`Futur proche d√©tect√©: "${item.auxiliary} ${item.verb}" ‚Üí voor + infinitif`);
                    } else {
                        translation.push(`voor [${item.verb}]`);
                        analysis.push({ original: `${item.auxiliary} ${item.verb}`, translation: `voor [${item.verb}]`, type: 'futur_proche (verbe inconnu)' });
                    }
                } else {
                    const word = item.word;
                    
                    const basicEntry = Object.keys(basicLexicon).find(key => basicLexicon[key].fr === word);
                    if (basicEntry) {
                        translation.push(basicEntry);
                        analysis.push({ original: word, translation: basicEntry, type: basicLexicon[basicEntry].type });
                        return;
                    }
                    
                    const nounEntry = Object.keys(nouns).find(key => nouns[key].fr === word);
                    if (nounEntry) {
                        translation.push(nounEntry);
                        analysis.push({ original: word, translation: nounEntry, type: 'nom' });
                        return;
                    }
                    
                    const verbEntry = findFrenchVerb(word);
                    if (verbEntry) {
                        const nilfForm = conjugateNilfgaardian(verbEntry.nilfInfinitif, subject, verbEntry.tense);
                        translation.push(nilfForm);
                        analysis.push({ original: word, translation: nilfForm, type: 'verbe (' + subject + ', ' + verbEntry.tense + ')' });
                        grammarNotes.push(`Verbe "${word}" conjugu√© pour "${subject}" au ${verbEntry.tense}`);
                        return;
                    }
                    
                    translation.push(`[${word}]`);
                    analysis.push({ original: word, translation: `[inconnu]`, type: 'inconnu' });
                }
            });
            
            return { translation: translation.join(' '), analysis, grammar: grammarNotes };
        }

        // Interface
        function swapLanguages() {
            const inputLabel = document.getElementById('input-label');
            const outputLabel = document.getElementById('output-label');
            const inputText = document.getElementById('input-text');
            const outputText = document.getElementById('output-text');
            
            [inputLabel.textContent, outputLabel.textContent] = [outputLabel.textContent, inputLabel.textContent];
            [inputText.value, outputText.value] = [outputText.value, inputText.value];
            
            currentDirection = currentDirection === 'conlang-to-french' ? 'french-to-conlang' : 'conlang-to-french';
            document.querySelectorAll('.lang-option').forEach(btn => btn.classList.toggle('active'));
        }

        function translate() {
            const inputText = document.getElementById('input-text').value.trim();
            const outputText = document.getElementById('output-text');
            const analysis = document.getElementById('analysis');
            
            if (!inputText) return;

            let result;
            if (currentDirection === 'conlang-to-french') {
                result = translateToFrench(inputText);
            } else {
                result = translateToConlang(inputText);
            }
            
            outputText.value = result.translation;
            showAnalysis(result.analysis, result.grammar);
            analysis.style.display = 'block';
        }

        function showAnalysis(analysisData, grammarNotes) {
            const wordAnalysis = document.getElementById('word-analysis');
            const grammarDiv = document.getElementById('grammar-notes');
            
            wordAnalysis.innerHTML = '';
            analysisData.forEach(item => {
                const tag = document.createElement('div');
                tag.className = 'word-tag';
                tag.innerHTML = `<strong>${item.original}</strong> ‚Üí ${item.translation} <em>(${item.type})</em>`;
                wordAnalysis.appendChild(tag);
            });

            grammarDiv.innerHTML = grammarNotes ? 
                grammarNotes.map(note => `<div>üìù ${note}</div>`).join('') : '';
        }

        function loadDictionary() {
            const dictContent = document.getElementById('dictionary-content');
            
            Object.keys(basicLexicon).forEach(word => {
                const entry = document.createElement('div');
                entry.className = 'dict-entry';
                entry.innerHTML = `<strong>${word}</strong> ‚Üí ${basicLexicon[word].fr} <em>(${basicLexicon[word].type})</em>`;
                dictContent.appendChild(entry);
            });
            
            ['vaar', 'voor'].forEach(word => {
                const entry = document.createElement('div');
                entry.className = 'dict-entry';
                entry.innerHTML = `<strong>${word}</strong> ‚Üí ${word === 'vaar' ? 'pass√© compos√©' : 'futur proche'} <em>(auxiliaire)</em>`;
                dictContent.appendChild(entry);
            });
            
            Object.keys(nouns).forEach(word => {
                const entry = document.createElement('div');
                entry.className = 'dict-entry';
                entry.innerHTML = `<strong>${word}</strong> ‚Üí ${nouns[word].fr} <em>(nom)</em>`;
                dictContent.appendChild(entry);
            });
            
            Object.keys(verbs).forEach(word => {
                const entry = document.createElement('div');
                entry.className = 'dict-entry';
                entry.innerHTML = `<strong>${word}</strong> ‚Üí ${verbs[word].fr} <em>(verbe, radical: ${verbs[word].radical})</em>`;
                dictContent.appendChild(entry);
            });
        }

        window.onload = function() {
            loadDictionary();
            translate();
        };

        document.getElementById('input-text').addEventListener('input', function() {
            setTimeout(translate, 300);
        });

        window.addVerb = function(nilfInfinitif, radical, frenchInfinitif) {
            verbs[nilfInfinitif] = { radical, fr: frenchInfinitif };
            loadDictionary();
            console.log(`Verbe ajout√©: ${nilfInfinitif} (${radical}) ‚Üí ${frenchInfinitif}`);
        };

        window.addNoun = function(nilfWord, frenchWord, genderFr, genderNilf) {
            nouns[nilfWord] = { fr: frenchWord, gender_fr: genderFr, gender_conlang: genderNilf };
            loadDictionary();
            console.log(`Nom ajout√©: ${nilfWord} ‚Üí ${frenchWord}`);
        };
    </script>
</body>
</html>
